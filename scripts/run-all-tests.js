#!/usr/bin/env node

/**
 * Script para ejecutar todos los tests del proyecto con informes detallados
 * Este script ejecuta diferentes tipos de tests y genera un informe completo
 */

const { spawn } = require('child_process');
const fs = require('fs');
const path = require('path');

class TestRunner {
  constructor() {
    this.results = {
      validations: { passed: 0, failed: 0, skipped: 0 },
      api: { passed: 0, failed: 0, skipped: 0 },
      components: { passed: 0, failed: 0, skipped: 0 },
      integration: { passed: 0, failed: 0, skipped: 0 },
      total: { passed: 0, failed: 0, skipped: 0 }
    };
    this.startTime = Date.now();
  }

  async runCommand(command, args = []) {
    return new Promise((resolve, reject) => {
      console.log(`üîÑ Ejecutando: ${command} ${args.join(' ')}`);
      
      const process = spawn(command, args, {
        stdio: 'pipe',
        shell: true,
        cwd: process.cwd()
      });

      let stdout = '';
      let stderr = '';

      process.stdout.on('data', (data) => {
        stdout += data.toString();
        process.stdout.write(data); // Mostrar output en tiempo real
      });

      process.stderr.on('data', (data) => {
        stderr += data.toString();
        process.stderr.write(data);
      });

      process.on('close', (code) => {
        if (code === 0) {
          resolve({ stdout, stderr, code });
        } else {
          resolve({ stdout, stderr, code }); // No rechazar para continuar con otros tests
        }
      });

      process.on('error', (err) => {
        reject(err);
      });
    });
  }

  parseJestOutput(output) {
    const stats = {
      passed: 0,
      failed: 0,
      skipped: 0
    };

    // Parsear resultados de Jest
    const passedMatch = output.match(/(\d+) passed/);
    const failedMatch = output.match(/(\d+) failed/);
    const skippedMatch = output.match(/(\d+) skipped/);

    if (passedMatch) stats.passed = parseInt(passedMatch[1]);
    if (failedMatch) stats.failed = parseInt(failedMatch[1]);
    if (skippedMatch) stats.skipped = parseInt(skippedMatch[1]);

    return stats;
  }

  async runValidationTests() {
    console.log('\nüìã === EJECUTANDO TESTS DE VALIDACIONES ===\n');
    
    try {
      const result = await this.runCommand('npm', ['run', 'test:jest', '--', '__tests__/validations/', '--verbose']);
      const stats = this.parseJestOutput(result.stdout);
      this.results.validations = stats;
      
      console.log(`\n‚úÖ Tests de validaciones completados:`);
      console.log(`   Passed: ${stats.passed}`);
      console.log(`   Failed: ${stats.failed}`);
      console.log(`   Skipped: ${stats.skipped}`);
      
      return result.code === 0;
    } catch (error) {
      console.error('‚ùå Error ejecutando tests de validaciones:', error.message);
      return false;
    }
  }

  async runApiTests() {
    console.log('\nüîå === EJECUTANDO TESTS DE API ===\n');
    
    try {
      const result = await this.runCommand('npm', ['run', 'test:jest', '--', '__tests__/api/', '--verbose']);
      const stats = this.parseJestOutput(result.stdout);
      this.results.api = stats;
      
      console.log(`\n‚úÖ Tests de API completados:`);
      console.log(`   Passed: ${stats.passed}`);
      console.log(`   Failed: ${stats.failed}`);
      console.log(`   Skipped: ${stats.skipped}`);
      
      return result.code === 0;
    } catch (error) {
      console.error('‚ùå Error ejecutando tests de API:', error.message);
      return false;
    }
  }

  async runComponentTests() {
    console.log('\nüß© === EJECUTANDO TESTS DE COMPONENTES ===\n');
    
    try {
      const result = await this.runCommand('npm', ['run', 'test:jest', '--', '__tests__/components/', '--verbose']);
      const stats = this.parseJestOutput(result.stdout);
      this.results.components = stats;
      
      console.log(`\n‚úÖ Tests de componentes completados:`);
      console.log(`   Passed: ${stats.passed}`);
      console.log(`   Failed: ${stats.failed}`);
      console.log(`   Skipped: ${stats.skipped}`);
      
      return result.code === 0;
    } catch (error) {
      console.error('‚ùå Error ejecutando tests de componentes:', error.message);
      return false;
    }
  }

  async runIntegrationTests() {
    console.log('\nüîÑ === EJECUTANDO TESTS DE INTEGRACI√ìN E2E ===\n');
    
    try {
      const result = await this.runCommand('npm', ['run', 'test:jest', '--', '__tests__/integration/', '--verbose']);
      const stats = this.parseJestOutput(result.stdout);
      this.results.integration = stats;
      
      console.log(`\n‚úÖ Tests de integraci√≥n completados:`);
      console.log(`   Passed: ${stats.passed}`);
      console.log(`   Failed: ${stats.failed}`);
      console.log(`   Skipped: ${stats.skipped}`);
      
      return result.code === 0;
    } catch (error) {
      console.error('‚ùå Error ejecutando tests de integraci√≥n:', error.message);
      return false;
    }
  }

  async runCoverageReport() {
    console.log('\nüìä === GENERANDO REPORTE DE COBERTURA ===\n');
    
    try {
      const result = await this.runCommand('npm', ['run', 'test:jest:coverage']);
      
      if (result.code === 0) {
        console.log('‚úÖ Reporte de cobertura generado exitosamente');
        console.log('üìÅ Reporte disponible en: ./coverage/lcov-report/index.html');
      } else {
        console.log('‚ö†Ô∏è  Reporte de cobertura completado con advertencias');
      }
      
      return true;
    } catch (error) {
      console.error('‚ùå Error generando reporte de cobertura:', error.message);
      return false;
    }
  }

  calculateTotals() {
    const categories = ['validations', 'api', 'components', 'integration'];
    
    categories.forEach(category => {
      this.results.total.passed += this.results[category].passed;
      this.results.total.failed += this.results[category].failed;
      this.results.total.skipped += this.results[category].skipped;
    });
  }

  generateReport() {
    const endTime = Date.now();
    const duration = ((endTime - this.startTime) / 1000).toFixed(2);
    
    this.calculateTotals();
    
    const report = `
    
üß™ === REPORTE COMPLETO DE PRUEBAS ===

‚è±Ô∏è  Tiempo total de ejecuci√≥n: ${duration} segundos

üìã RESUMEN POR CATEGOR√çA:
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
‚îÇ Categor√≠a       ‚îÇ Passed  ‚îÇ Failed  ‚îÇ Skipped  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Validaciones    ‚îÇ ${String(this.results.validations.passed).padEnd(7)} ‚îÇ ${String(this.results.validations.failed).padEnd(7)} ‚îÇ ${String(this.results.validations.skipped).padEnd(8)} ‚îÇ
‚îÇ API             ‚îÇ ${String(this.results.api.passed).padEnd(7)} ‚îÇ ${String(this.results.api.failed).padEnd(7)} ‚îÇ ${String(this.results.api.skipped).padEnd(8)} ‚îÇ
‚îÇ Componentes     ‚îÇ ${String(this.results.components.passed).padEnd(7)} ‚îÇ ${String(this.results.components.failed).padEnd(7)} ‚îÇ ${String(this.results.components.skipped).padEnd(8)} ‚îÇ
‚îÇ Integraci√≥n     ‚îÇ ${String(this.results.integration.passed).padEnd(7)} ‚îÇ ${String(this.results.integration.failed).padEnd(7)} ‚îÇ ${String(this.results.integration.skipped).padEnd(8)} ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ TOTAL           ‚îÇ ${String(this.results.total.passed).padEnd(7)} ‚îÇ ${String(this.results.total.failed).padEnd(7)} ‚îÇ ${String(this.results.total.skipped).padEnd(8)} ‚îÇ
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ

üéØ RESULTADO GENERAL:
${this.results.total.failed === 0 ? '‚úÖ TODOS LOS TESTS PASARON' : '‚ùå ALGUNOS TESTS FALLARON'}

üìà ESTAD√çSTICAS:
‚Ä¢ Tests ejecutados: ${this.results.total.passed + this.results.total.failed + this.results.total.skipped}
‚Ä¢ Tasa de √©xito: ${this.results.total.passed + this.results.total.failed > 0 ? 
  ((this.results.total.passed / (this.results.total.passed + this.results.total.failed)) * 100).toFixed(1) : 0}%
‚Ä¢ Cobertura: Consulta ./coverage/lcov-report/index.html

üõ†Ô∏è  SIGUIENTES PASOS:
${this.results.total.failed > 0 ? 
  '‚Ä¢ Revisar tests fallidos y corregir problemas\n‚Ä¢ Re-ejecutar tests espec√≠ficos: npm run test:jest -- <archivo-de-test>' : 
  '‚Ä¢ Sistema listo para deployment\n‚Ä¢ Considerar agregar m√°s tests para nuevas funcionalidades'}

üìù ARCHIVOS DE REPORTE:
‚Ä¢ Reporte HTML: ./test-report/report.html
‚Ä¢ Cobertura HTML: ./coverage/lcov-report/index.html
‚Ä¢ Logs detallados: Salida de consola arriba

`;

    console.log(report);

    // Guardar reporte en archivo
    const reportPath = path.join(process.cwd(), 'test-results.txt');
    fs.writeFileSync(reportPath, report);
    console.log(`üíæ Reporte guardado en: ${reportPath}`);

    return this.results.total.failed === 0;
  }

  async run() {
    console.log('üöÄ === INICIANDO SUITE COMPLETA DE PRUEBAS ===\n');
    console.log('Este proceso ejecutar√° todos los tests del sistema de concursos:');
    console.log('‚Ä¢ Tests de validaciones (frontend y backend)');
    console.log('‚Ä¢ Tests de API (CRUD y manejo de errores)');
    console.log('‚Ä¢ Tests de componentes React');
    console.log('‚Ä¢ Tests de integraci√≥n E2E');
    console.log('‚Ä¢ Reporte de cobertura de c√≥digo\n');

    // Ejecutar cada categor√≠a de tests
    await this.runValidationTests();
    await this.runApiTests();
    await this.runComponentTests();
    await this.runIntegrationTests();
    
    // Generar reporte de cobertura
    await this.runCoverageReport();
    
    // Generar reporte final
    const success = this.generateReport();
    
    process.exit(success ? 0 : 1);
  }
}

// Ejecutar si es llamado directamente
if (require.main === module) {
  const runner = new TestRunner();
  runner.run().catch(error => {
    console.error('üí• Error fatal ejecutando tests:', error);
    process.exit(1);
  });
}

module.exports = TestRunner;
