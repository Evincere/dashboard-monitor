"use client";
import { apiUrl, routeUrl } from '@/lib/utils';

import { useState, useEffect, useCallback } from "react";
import { useParams, useRouter } from "next/navigation";
import { useValidationStore } from "@/stores/validationStore";
import { useValidationShortcuts } from "@/hooks/useKeyboardShortcuts";
import {
  DocumentSkeleton,
  DocumentListSkeleton,
  ValidationPanelSkeleton,
} from "@/components/validation/DocumentSkeleton";
import { ValidationProgress } from "@/components/validation/ValidationProgress";
import {
  KeyboardShortcuts,
  KeyboardShortcutsHelp,
} from "@/components/validation/KeyboardShortcuts";
import {
  ArrowLeft,
  CheckCircle,
  XCircle,
  Clock,
  AlertTriangle,
  ChevronRight,
  ChevronLeft,
  Download,
  FileText,
  User,
  Target,
  Calendar,
  MapPin,
  Maximize,
  Minimize,
  PanelLeftClose,
  PanelLeftOpen,
  Mail,
  Phone,
} from "lucide-react";
import { Button } from "@/components/ui/button";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog";
import { RefreshCw } from "lucide-react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Progress } from "@/components/ui/progress";
import { Textarea } from "@/components/ui/textarea";
import { SidebarTrigger } from "@/components/ui/sidebar";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { useToast } from "@/hooks/use-toast";
import { DocumentTypeBadge } from "@/components/ui/document-type-badge";
import ValidationCompletionModal from "@/components/validation/ValidationCompletionModal";
import backendClient from "@/lib/backend-client";

interface Document {
  id: string;
  fileName: string;
  originalName: string;
  filePath: string;
  fileSize: number;
  documentType: string;
  validationStatus: "PENDING" | "APPROVED" | "REJECTED";
  isRequired: boolean;
  uploadDate: string;
  validatedAt?: string;
  validatedBy?: string;
  comments?: string;
  rejectionReason?: string;
  thumbnailUrl?: string;
}

interface PostulantInfo {
  user: {
    dni: string;
    fullName: string;
    email: string;
  };
  inscription: {
    id: string;
    state: string;
    centroDeVida: string;
    createdAt: string;
  };
  contest: {
    title: string;
    position: string;
  };
}

interface ValidationData {
  postulant: PostulantInfo;
  documents: Document[];
  stats: {
    total: number;
    pending: number;
    approved: number;
    rejected: number;
    required: number;
    completionPercentage: number;
  };
}

const REJECTION_REASONS = [
  "Documento ilegible o de mala calidad",
  "Documento incompleto",
  "Documento no corresponde al tipo requerido",
  "Informaci√≥n inconsistente con otros documentos",
  "Documento vencido o no vigente",
  "Falta informaci√≥n requerida",
  "Formato de archivo no v√°lido",
  "Documento no pertenece al postulante",
  "Otro (especificar en comentarios)",
];

export default function DocumentValidationPage() {
  const params = useParams();
  const router = useRouter();
  const { toast } = useToast();
  const dni = params.dni as string;

  // Zustand store
  const {
    documents,
    currentDocument,
    postulant,
    stats,
    loading,
    submitting,
    setDocuments,
    setCurrentDocument,
    setPostulant,
    setStats,
    setLoading,
    approveDocument,
    rejectDocument,
    goToNextPending,
    goToPreviousPending,
    updateStats,
    reset,
  } = useValidationStore();

  // Local state for UI
  const [comments, setComments] = useState("");
  const [rejectionReason, setRejectionReason] = useState("");
  const [showRejectionForm, setShowRejectionForm] = useState(false);
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [isSidebarCollapsed, setIsSidebarCollapsed] = useState(true);
  const [allPostulantsList, setAllPostulantsList] = useState<string[]>([]);
  const [showCompletionModal, setShowCompletionModal] = useState(false);
  const [modalDismissed, setModalDismissed] = useState(false);
  const [isProcessingApproval, setIsProcessingApproval] = useState(false);

  // Fetch all postulants list for navigation
  const fetchAllPostulantsList = async () => {
    console.log('üîÑ fetchAllPostulantsList - Iniciando carga de lista de postulantes...');
    try {
      console.log('üì° Haciendo fetch a /api/proxy-backend/inscriptions con tama√±o=1000');
      const response = await fetch(apiUrl('proxy-backend/inscriptions?size=1000'));
      console.log('üì® Respuesta recibida:', {
        ok: response.ok,
        status: response.status,
        statusText: response.statusText
      });
      
      if (response.ok) {
        const result = await response.json();
        console.log('üìã Datos de API recibidos:', {
          success: result.success,
          dataLength: result.data?.content?.length || 0,
          firstItem: result.data?.content?.[0]
        });
        
        if (result.success && result.data && result.data.content) {
          // Extract DNIs and sort alphabetically by full name
          console.log('üîß Procesando datos...');
          
          // SOLO incluir postulantes que necesiten validaci√≥n (COMPLETED_WITH_DOCS o PENDING)
          // NO incluir los ya APPROVED o REJECTED en la lista de navegaci√≥n
          const needsValidation = result.data.content.filter((p: any) => {
            const hasName = p.userInfo?.fullName;
            const hasDni = p.userInfo?.dni;
            const needsValidation = p.state === 'COMPLETED_WITH_DOCS' || p.state === 'PENDING';
            
            console.log(`üìù Postulante ${p.userInfo?.fullName || 'N/A'} (${p.userInfo?.dni || 'N/A'}): estado=${p.state}, necesitaValidaci√≥n=${needsValidation}`);
            
            return hasName && hasDni && needsValidation;
          });
          
          console.log('üîç Postulantes que necesitan validaci√≥n:', needsValidation.length);
          
          // Buscar el postulante actual en todos los datos
          const currentPostulant = result.data.content.find((p: any) => p.userInfo?.dni === dni);
          console.log('üîé Postulante actual encontrado:', currentPostulant ? 
            `${currentPostulant.userInfo.fullName} (${currentPostulant.userInfo.dni}) - Estado: ${currentPostulant.state}` : 'No encontrado');
          
          // Solo usar los que necesitan validaci√≥n para la navegaci√≥n
          let validationCandidates = [...needsValidation];
          
          // Si el postulante actual no est√° en la lista (porque ya fue procesado), NO lo a√±adimos
          // Esto evita que se pueda navegar a postulantes ya aprobados/rechazados
          
          if (validationCandidates.length === 0) {
            console.log('‚ö†Ô∏è No se encontraron postulantes pendientes de validaci√≥n');
            setAllPostulantsList([]);
            return;
          }
          
          const postulants = validationCandidates
            .sort((a: any, b: any) => {
              const nameA = a.userInfo.fullName.toLowerCase();
              const nameB = b.userInfo.fullName.toLowerCase();
              return nameA.localeCompare(nameB, 'es', { numeric: true, sensitivity: 'base' });
            })
            .map((p: any) => p.userInfo.dni);
          
          console.log('üìù Lista final de DNIs pendientes ordenada:', postulants);
          setAllPostulantsList(postulants);
          console.log('‚úÖ Lista de postulantes cargada exitosamente:', postulants.length, 'postulantes pendientes');
        } else {
          console.log('‚ùå API no devolvi√≥ datos v√°lidos:', result);
        }
      } else {
        console.log('‚ùå Error en respuesta de API:', response.status, response.statusText);
      }
    } catch (error) {
      console.error('üí• Error fetching postulants list:', error);
    }
  };

  // Fetch validation data
  const fetchValidationData = async () => {
    setLoading(true);
    try {
      const response = await fetch(apiUrl(`postulations/${dni}/documents`));

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const result = await response.json();

      if (!result.success) {
        throw new Error(result.error || "API returned success: false");
      }

      // Update store
      setDocuments(result.data.documents);
      setPostulant(result.data.postulant);
      setStats(result.data.stats);

      // Set first pending document as current
      const firstPending = result.data.documents.find(
        (doc: Document) => doc.validationStatus === "PENDING"
      );
      if (firstPending) {
        setCurrentDocument(firstPending);
      } else if (result.data.documents.length > 0) {
        setCurrentDocument(result.data.documents[0]);
      }
    } catch (error) {
      console.error("Error fetching validation data:", error);
      toast({
        title: "Error",
        description: `No se pudieron cargar los documentos: ${
          error instanceof Error ? error.message : "Error desconocido"
        }`,
        variant: "destructive",
      });
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    console.log('üîÑ useEffect ejecut√°ndose con DNI:', dni);
    if (dni) {
      console.log('‚úÖ DNI v√°lido, iniciando carga de datos...');
      
      // Resetear estados de modal al cambiar de postulaci√≥n
      setShowCompletionModal(false);
      // Para navegaci√≥n entre postulaciones, NO marcar como dismissed inmediatamente
      // Esperar a que se carguen los datos para decidir
      
      fetchValidationData();
      
      console.log('üöÄ Llamando a fetchAllPostulantsList...');
      fetchAllPostulantsList();
    } else {
      console.log('‚ùå DNI no v√°lido:', dni);
    }

    // Cleanup on unmount
    return () => {
      console.log('üßπ Limpiando componente...');
      reset();
    };
  }, [dni]);

  // Handle download
  const handleDownload = useCallback(() => {
    if (!currentDocument) return;
    window.open(apiUrl(`documents/${currentDocument.id}/download`), "_blank");
  }, [currentDocument]);

  // Handle document approval
  const handleApprove = async () => {
    if (!currentDocument) return;

    try {
      await approveDocument(currentDocument.id, comments.trim() || undefined);

      toast({
        title: "Documento Aprobado",
        description: "El documento ha sido aprobado exitosamente",
        variant: "default",
      });

      // Clear form
      setComments("");
    } catch (error) {
      console.error("Error approving document:", error);
      toast({
        title: "Error",
        description: "No se pudo aprobar el documento",
        variant: "destructive",
      });
    }
  };

  // Handle document rejection
  const handleReject = async () => {
    if (!currentDocument || !rejectionReason.trim()) return;

    try {
      const fullReason = comments.trim()
        ? `${rejectionReason}. ${comments}`
        : rejectionReason;

      await rejectDocument(currentDocument.id, fullReason);

      toast({
        title: "Documento Rechazado",
        description: "El documento ha sido rechazado",
        variant: "destructive",
      });

      // Clear form
      setComments("");
      setRejectionReason("");
      setShowRejectionForm(false);
    } catch (error) {
      console.error("Error rejecting document:", error);
      toast({
        title: "Error",
        description: "No se pudo rechazar el documento",
        variant: "destructive",
      });
    }
  };

  // Keyboard shortcuts
  useValidationShortcuts({
    onApprove:
      currentDocument?.validationStatus === "PENDING"
        ? handleApprove
        : undefined,
    onReject:
      currentDocument?.validationStatus === "PENDING"
        ? () => setShowRejectionForm(true)
        : undefined,
    onNext: goToNextPending,
    onCancel: () => setShowRejectionForm(false),
    onDownload: handleDownload,
    enabled: !submitting,
  });

  // Check if all required documents are validated
  useEffect(() => {
    // Evitar procesamiento si no hay datos b√°sicos
    if (!documents.length || !postulant) {
      // Al inicio de carga, resetear dismissed para permitir modales autom√°ticos cuando corresponda
      setModalDismissed(false);
      return;
    }
    
    const requiredDocs = documents.filter(doc => doc.isRequired);
    const allRequiredValidated = requiredDocs.length > 0 && requiredDocs.every(doc => doc.validationStatus !== "PENDING");
    
    console.log('üìä Validation check:', {
      totalDocs: documents.length,
      requiredDocs: requiredDocs.length,
      allRequiredValidated,
      showCompletionModal,
      modalDismissed,
      postulantState: postulant?.inscription?.state,
      requiredDocsStatus: requiredDocs.map(doc => ({
        name: doc.documentType,
        status: doc.validationStatus,
        isRequired: doc.isRequired
      }))
    });
    
    // No hacer nada si ya est√° aprobado
    if (postulant.inscription.state === 'APPROVED') {
      console.log('‚è≠Ô∏è Postulante ya APPROVED, saltando validaciones');
      setModalDismissed(true); // Marcar como dismissed para postulantes aprobados
      return;
    }
    
    // Si todos los documentos requeridos est√°n validados (NO hay pendientes)
    if (allRequiredValidated) {
      console.log('‚úÖ Todos los documentos requeridos est√°n validados');
      
      // Caso 1: COMPLETED_WITH_DOCS - Iniciar autom√°ticamente validaci√≥n sin modal
      if (postulant.inscription.state === 'COMPLETED_WITH_DOCS') {
        console.log('üîÑ COMPLETED_WITH_DOCS detectado, iniciando validaci√≥n autom√°ticamente...');
        setModalDismissed(true); // Evitar modal durante el cambio autom√°tico
        
        // Usar una referencia para evitar m√∫ltiples llamadas
        const timeoutId = setTimeout(() => {
          // Verificar nuevamente que a√∫n estamos en COMPLETED_WITH_DOCS antes de proceder
          if (postulant.inscription.state === 'COMPLETED_WITH_DOCS') {
            handleInitiateValidation();
          }
        }, 100);
        
        return () => clearTimeout(timeoutId);
      }
      
      // Caso 2: PENDING - Mostrar modal de completado SOLO si no est√° dismissed y no se est√° mostrando ya
      if (postulant.inscription.state === 'PENDING' && !showCompletionModal && !modalDismissed) {
        console.log('üéØ PENDING con docs completados, abriendo modal de completado...');
        setShowCompletionModal(true);
      }
    } else {
      console.log('‚è≥ Todav√≠a hay documentos pendientes de validaci√≥n');
      
      // Si hay documentos pendientes, NO mostrar modal y asegurar que est√° cerrado
      if (showCompletionModal) {
        console.log('üìù Cerrando modal porque hay documentos pendientes...');
        setShowCompletionModal(false);
        setModalDismissed(true); // Marcar como dismissed hasta que se completen
      }
    }
  }, [
    documents.map(d => `${d.id}:${d.validationStatus}`).join(','), // Solo cambios en status de documentos
    postulant?.inscription?.state, // Solo cambios en estado de inscripci√≥n
    showCompletionModal,
    modalDismissed
  ]);

  // Helper function to navigate to next postulant in alphabetical order
  const navigateToNextPostulant = () => {
    console.log('üöÄ navigateToNextPostulant called');
    console.log('üìã allPostulantsList:', allPostulantsList);
    console.log('üîç Current DNI:', dni);
    console.log('üìä Lista length:', allPostulantsList?.length || 0);
    
    // Verificar si hay postulantes disponibles
    if (!allPostulantsList || allPostulantsList.length === 0) {
      console.log('‚ùå No hay postulantes pendientes en la lista, redirigiendo al dashboard');
      toast({
        title: "Validaci√≥n Completada",
        description: "No hay m√°s postulantes pendientes de validaci√≥n.",
      });
      setTimeout(() => {
        router.push(routeUrl('postulations'));
      }, 2000);
      return;
    }

    // Buscar el √≠ndice del postulante actual
    const currentIndex = allPostulantsList.indexOf(dni);
    console.log('üìç Current index:', currentIndex);
    
    // SI EL POSTULANTE ACTUAL NO EST√Å EN LA LISTA (porque fue aprobado/rechazado)
    if (currentIndex === -1) {
      console.log('üîç Current postulant not found in pending list (likely approved/rejected)');
      console.log('üìã Available pending DNIs:', allPostulantsList.slice(0, 5)); // Mostrar primeros 5
      
      // Ir al primer postulante pendiente disponible
      if (allPostulantsList.length > 0) {
        const firstPendingDni = allPostulantsList[0];
        console.log(`‚úÖ Navegando al primer postulante pendiente: ${firstPendingDni}`);
        const targetUrl = routeUrl(`postulations/${firstPendingDni}/documents/validation`);
        console.log(`üéØ Target URL: ${targetUrl}`);
        console.log("üéØ DEBUG - Current URL before navigation:", window.location.href);
        router.push(targetUrl);
        return;
      } else {
        console.log('üéâ No hay m√°s postulantes pendientes');
        toast({
          title: "Validaci√≥n Completada",
          description: "No hay m√°s postulantes pendientes de validaci√≥n.",
        });
        setTimeout(() => {
          router.push(routeUrl('postulations'));
        }, 2000);
        return;
      }
    }

    // NAVEGAR AL SIGUIENTE POSTULANTE PENDIENTE
    const nextIndex = currentIndex + 1;
    console.log('‚è≠Ô∏è Next index:', nextIndex);
    console.log('üìè List length:', allPostulantsList.length);
    
    if (nextIndex < allPostulantsList.length) {
      const nextDni = allPostulantsList[nextIndex];
      console.log(`‚úÖ Navegando al siguiente postulante pendiente: ${nextDni} (index: ${nextIndex})`);
      const targetUrl = routeUrl(`postulations/${nextDni}/documents/validation`);
      console.log(`üéØ Target URL: ${targetUrl}`);
      router.push(targetUrl);
    } else {
      console.log('üéâ Era el √∫ltimo postulante pendiente, redirigiendo al dashboard');
      toast({
        title: "Validaci√≥n Completada",
        description: "Has validado todos los postulantes pendientes. Redirigiendo al panel principal...",
      });
      setTimeout(() => {
        router.push(routeUrl('postulations'));
      }, 2000);
    }
  };


  // Funci√≥n para revertir estado de postulaci√≥n
  const revertPostulationState = async () => {
    if (!postulant?.user?.dni) return;
    try {
      setLoading(true);
      console.log('üîÑ Revirtiendo estado de postulaci√≥n:', postulant.user.dni);
      
      const response = await fetch(`/dashboard-monitor/api/postulations/${postulant.user.dni}/revert`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          revertedBy: 'admin',
          reason: 'Reversi√≥n administrativa para nueva evaluaci√≥n'
        })
      });
      
      const result = await response.json();
      
      if (!response.ok || !result.success) {
        throw new Error(result.error || 'Failed to revert');
      }
      
      toast({ 
        title: 'Estado Revertido', 
        description: `Postulaci√≥n revertida de ${result.data.inscription.previousState} a PENDING`
      });
      
      // Refresh validation data to update the UI
      await fetchValidationData();
      
    } catch (error) {
      console.error('Error reverting postulation:', error);
      toast({ 
        title: 'Error', 
        description: error instanceof Error ? error.message : 'Error al revertir', 
        variant: 'destructive' 
      });
    } finally {
      setLoading(false);
    }
  };

  // Modal handlers
  const handleApprovePostulationAndNext = async () => {
    try {
      if (!postulant?.inscription?.id) {
        throw new Error('ID de inscripci√≥n no encontrado');
      }

      // üöÄ ACTIVAR LOADING INMEDIATAMENTE
      setLoading(true);
      setShowCompletionModal(false); // Cerrar modal inmediatamente
      setModalDismissed(true);

      console.log('üü¢ Aprobando postulaci√≥n:', {
        inscriptionId: postulant.inscription.id,
        postulantName: postulant.user.fullName,
        dni: postulant.user.dni,
        currentState: postulant.inscription.state
      });

      // GUARDAR INFORMACI√ìN ANTES DE LA APROBACI√ìN
      const currentIndex = allPostulantsList?.indexOf(dni) || -1;
      const nextIndex = currentIndex + 1;
      const hasNextPostulant = nextIndex < (allPostulantsList?.length || 0);
      const nextDni = hasNextPostulant ? allPostulantsList?.[nextIndex] : null;

      console.log('üìä Pre-approval state:', {
        currentIndex,
        nextIndex,
        hasNextPostulant,
        nextDni,
        totalPostulants: allPostulantsList?.length || 0
      });

      // PASO 1: Si est√° en COMPLETED_WITH_DOCS, primero cambiar a PENDING
      if (postulant.inscription.state === 'COMPLETED_WITH_DOCS') {
        console.log('üü° Estado actual es COMPLETED_WITH_DOCS, cambiando primero a PENDING...');
        
        const initiateResponse = await fetch(apiUrl(`postulations/${dni}/initiate-validation`), {
          method: 'PATCH',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            inscriptionId: postulant.inscription.id,
            note: 'Validaci√≥n de documentos iniciada para aprobaci√≥n'
          }),
        });

        const initiateResult = await initiateResponse.json();

        if (!initiateResult.success) {
          throw new Error(initiateResult.error || 'Error al iniciar la validaci√≥n');
        }
        
        console.log('‚úÖ Estado cambiado a PENDING exitosamente');
      }

      // PASO 2: Ahora aprobar la postulaci√≥n (PENDING -> APPROVED)
      console.log('üü¢ Aprobando postulaci√≥n (PENDING -> APPROVED)...');
      
      const response = await fetch(apiUrl(`postulations/${dni}/approve`), {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          inscriptionId: postulant.inscription.id,
          note: 'Postulaci√≥n aprobada tras validaci√≥n de documentos'
        }),
      });

      const result = await response.json();

      if (!result.success) {
        throw new Error(result.error || 'Error al aprobar la postulaci√≥n');
      }
      
      toast({
        title: "Postulaci√≥n Aprobada",
        description: "Postulaci√≥n aprobada. Actualizando lista y navegando...",
      });
      
      // Close modal immediately and mark as dismissed
      setShowCompletionModal(false);
      setModalDismissed(true);
      
      // Actualizar lista de postulantes despu√©s de aprobar
      console.log('üîÑ Actualizando lista de postulantes despu√©s de aprobar...');
      await fetchAllPostulantsList();
      
      // NAVEGAR DESPU√âS DE ACTUALIZAR LA LISTA
      setTimeout(async () => {
        // Refrescar la lista una vez m√°s para obtener el estado m√°s actualizado
        await fetchAllPostulantsList();
        
        // Encontrar el siguiente postulante que NO sea el actual y que est√© pendiente
        const availablePostulants = allPostulantsList.filter(postulantDni => postulantDni !== dni);
        
        if (availablePostulants.length > 0) {
          const nextPostulant = availablePostulants[0];
          console.log(`‚úÖ Navegando al siguiente postulante disponible: ${nextPostulant}`);
          const targetUrl = routeUrl(`postulations/${nextPostulant}/documents/validation`);
          router.push(targetUrl);
        } else {
          console.log('üéâ No hay m√°s postulantes pendientes, redirigiendo al dashboard');
          router.push(routeUrl('postulations'));
        }
      }, 1500);
      
    } catch (error) {
      console.error('Error approving postulation:', error);
      toast({
        title: "Error",
        description: error instanceof Error ? error.message : "No se pudo aprobar la postulaci√≥n",
        variant: "destructive",
      });
    }
  }

  const handleApproveAndContinue = async () => {
    try {
      setIsProcessing(true);
      console.log("‚úÖ Iniciando aprobaci√≥n y navegaci√≥n...");
      
      // 1. Aprobar la postulaci√≥n actual
      const approveResponse = await fetch(apiUrl(`postulations/${dni}/approve`), {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          note: 'Postulaci√≥n aprobada - Navegando a siguiente autom√°ticamente' 
        })
      });
      
      if (!approveResponse.ok) {
        const errorData = await approveResponse.json();
        throw new Error(errorData.error || 'Error al aprobar postulaci√≥n');
      }
      
      console.log("‚úÖ Postulaci√≥n aprobada, buscando siguiente...");
      
      // 2. Buscar pr√≥xima postulaci√≥n inmediatamente
      const nextResponse = await fetch(
        apiUrl(`validation/next-postulation?currentDni=${dni}&excludeStates=APPROVED,REJECTED`),
        { signal: AbortSignal.timeout(10000) }
      );
      
      if (!nextResponse.ok) {
        throw new Error(`Error HTTP ${nextResponse.status} al buscar pr√≥xima postulaci√≥n`);
      }
      
      const nextData = await nextResponse.json();
      
      if (!nextData.success) {
        throw new Error(nextData.error || 'Error al obtener pr√≥xima postulaci√≥n');
      }
      
      if (!nextData.hasNext || !nextData.dni) {
        toast({
          title: "üéâ Validaci√≥n completa",
          description: "No hay m√°s postulaciones pendientes de validaci√≥n",
          variant: "default"
        });
        
        // Navegar al listado principal
        setTimeout(() => {
          router.push(routeUrl('postulations'));
        }, 1500);
        return;
      }
      
      // 3. Navegar directamente a la pr√≥xima postulaci√≥n
      console.log(`üöÄ Navegando a pr√≥xima postulaci√≥n: ${nextData.dni}`);
      
      toast({
        title: "‚úÖ Aprobada",
        description: `Navegando a postulaci√≥n ${nextData.dni}...`,
        variant: "default"
      });
      
      // Navegaci√≥n inmediata
      const targetPath = routeUrl(`postulations/${nextData.dni}/documents/validation`);
      console.log("üéØ DEBUG - Target path:", targetPath);
      console.log("üéØ DEBUG - Base path from env:", process.env.NEXT_PUBLIC_BASE_PATH);
      console.log("üéØ DEBUG - Current URL:", window.location.href);
      router.push(targetPath);
      
    } catch (error) {
      console.error("‚ùå Error en aprobaci√≥n y navegaci√≥n:", error);
      toast({
        title: "Error",
        description: error instanceof Error ? error.message : "Error desconocido",
        variant: "destructive"
      });
    } finally {
      setIsProcessing(false);
    }
  };;

  // Keep the old function for compatibility when only approving without continuing
  const handleApprovePostulation = async () => {
    try {
      toast({
        title: "Postulaci√≥n Aprobada",
        description: "La postulaci√≥n ha sido aprobada exitosamente.",
      });
      
      setShowCompletionModal(false);
      setTimeout(() => {
        router.push(routeUrl('postulations'));
      }, 2000);
      
    } catch (error) {
      console.error('Error approving postulation:', error);
      toast({
        title: "Error",
        description: "No se pudo aprobar la postulaci√≥n",
        variant: "destructive",
      });
    }
  };

  // Function to initiate validation (change state to PENDING)
  const handleInitiateValidation = async () => {
    try {
      if (!postulant?.inscription?.id) {
        throw new Error('ID de inscripci√≥n no encontrado');
      }

      // Verificar estado actual antes de intentar cambio
      if (postulant.inscription.state === 'PENDING') {
        console.log('‚ö†Ô∏è La postulaci√≥n ya est√° en estado PENDING, no se requiere cambio de estado');
        return; // No hacer nada si ya est√° en PENDING
      }

      console.log('üü° Iniciando validaci√≥n (cambio a PENDING):', {
        inscriptionId: postulant.inscription.id,
        postulantName: postulant.user.fullName,
        dni: postulant.user.dni,
        currentState: postulant.inscription.state
      });

      // Call the API route to initiate validation (change to PENDING)
      const response = await fetch(apiUrl(`postulations/${dni}/initiate-validation`), {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          inscriptionId: postulant.inscription.id,
          note: 'Validaci√≥n de documentos iniciada autom√°ticamente'
        }),
      });

      const result = await response.json();

      if (!result.success) {
        throw new Error(result.error || 'Error al iniciar la validaci√≥n');
      }
      
      // Refresh the validation data to update the postulant state
      await fetchValidationData();
      
      console.log('‚úÖ Validaci√≥n iniciada autom√°ticamente, estado cambiado a PENDING');
      
      // Despu√©s del cambio de estado, esperar un poco y mostrar modal si docs est√°n completos
      setTimeout(() => {
        const requiredDocs = documents.filter(doc => doc.isRequired);
        const allRequiredValidated = requiredDocs.length > 0 && requiredDocs.every(doc => doc.validationStatus !== "PENDING");
        
        if (allRequiredValidated) {
          console.log('üìã Docs ya completos despu√©s de cambio a PENDING, mostrando modal...');
          setModalDismissed(false);
          setShowCompletionModal(true);
        }
      }, 500);
      
    } catch (error) {
      console.error('Error initiating validation:', error);
      toast({
        title: "Error",
        description: error instanceof Error ? error.message : "No se pudo iniciar la validaci√≥n",
        variant: "destructive",
      });
    }
  };

  // Function to reject postulation and continue to next one
  const handleRejectPostulationAndNext = async () => {
    try {
      if (!postulant?.inscription?.id) {
        throw new Error('ID de inscripci√≥n no encontrado');
      }

      // üöÄ ACTIVAR LOADING INMEDIATAMENTE
      setLoading(true);
      setShowCompletionModal(false); // Cerrar modal inmediatamente
      setModalDismissed(true);

      console.log('üî¥ Rechazando postulaci√≥n:', {
        inscriptionId: postulant.inscription.id,
        postulantName: postulant.user.fullName,
        dni: postulant.user.dni
      });

      // Llamar al API route local para rechazar la inscripci√≥n
      const response = await fetch(apiUrl(`postulations/${dni}/reject`), {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          inscriptionId: postulant.inscription.id,
          note: 'Postulaci√≥n rechazada tras validaci√≥n de documentos'
        }),
      });

      const result = await response.json();

      if (!result.success) {
        throw new Error(result.error || 'Error al rechazar la postulaci√≥n');
      }
      
      toast({
        title: "Postulaci√≥n Rechazada",
        description: "Postulaci√≥n rechazada. Navegando a la siguiente...",
        variant: "destructive",
      });
      
      // Close modal immediately and mark as dismissed
      setShowCompletionModal(false);
      setModalDismissed(true);
      
      // Small delay to show toast, then navigate to next postulant
      setTimeout(() => {
        navigateToNextPostulant();
      }, 1500);
      
    } catch (error) {
      console.error('Error rejecting postulation:', error);
      toast({
        title: "Error",
        description: error instanceof Error ? error.message : "No se pudo rechazar la postulaci√≥n",
        variant: "destructive",
      });
    }
  };

  // Keep the old function for compatibility when only rejecting without continuing
  const handleRejectPostulation = async () => {
    try {
      // Here you would make an API call to reject the postulation
      // TODO: Implement actual API call to update postulation status to REJECTED
      
      toast({
        title: "Postulaci√≥n Rechazada",
        description: "La postulaci√≥n ha sido rechazada. Los documentos quedan en estado de correcci√≥n pendiente.",
        variant: "destructive",
      });
      
      // Close modal immediately and mark as dismissed
      setShowCompletionModal(false);
      setModalDismissed(true);
      
      // Small delay to show toast, then redirect
      setTimeout(() => {
        // Navigate back to postulations list
        router.push(routeUrl('postulations'));
      }, 2000);
      
    } catch (error) {
      console.error('Error rejecting postulation:', error);
      toast({
        title: "Error",
        description: "No se pudo rechazar la postulaci√≥n",
        variant: "destructive",
      });
    }
  };

  const handleGenerateEmailTemplate = (emailContent: string) => {
    // Here you would handle the email template generation
    console.log('Generated email template:', emailContent);
    toast({
      title: "Template Generado",
      description: "El template del correo electr√≥nico ha sido generado",
    });
  };

  const handleNextPostulation = () => {
    setShowCompletionModal(false);
    setModalDismissed(true);
    setTimeout(() => {
      navigateToNextPostulant();
    }, 500);
  };

  // Handle revert document status
  const handleRevertStatus = () => {
    if (!currentDocument) return;

    // Reset document status to PENDING
    const updatedDocuments = documents.map(doc =>
      doc.id === currentDocument.id
        ? {
            ...doc,
            validationStatus: 'PENDING' as const,
            validatedAt: undefined,
            validatedBy: undefined,
            comments: undefined,
            rejectionReason: undefined
          }
        : doc
    );
    
    // Update store and current document immediately
    setDocuments(updatedDocuments);
    
    // Find and set the updated current document to trigger re-render
    const updatedCurrentDocument = updatedDocuments.find(doc => doc.id === currentDocument.id);
    if (updatedCurrentDocument) {
      setCurrentDocument(updatedCurrentDocument);
    }
    
    updateStats();
    
    // Reset modal dismissed state so it can show again if all required docs become validated
    setModalDismissed(false);
    
    toast({
      title: "Estado Revertido",
      description: "El documento ha vuelto al estado pendiente",
    });
  };
  
  // Reset modalDismissed when documents change (after approval/rejection)
  useEffect(() => {
    // Solo procesar si hay documentos y postulante
    if (!documents.length || !postulant) return;
    
    const requiredDocs = documents.filter(doc => doc.isRequired);
    const allRequiredValidated = requiredDocs.length > 0 && requiredDocs.every(doc => doc.validationStatus !== "PENDING");
    
    // Si acabamos de completar todos los documentos durante la validaci√≥n activa (PENDING)
    if (allRequiredValidated && modalDismissed && postulant.inscription.state === 'PENDING') {
      console.log('üîÑ Documentos completados durante validaci√≥n PENDING, reseteando modalDismissed...');
      setModalDismissed(false);
    }
  }, [documents.map(d => d.validationStatus).join(','), postulant?.inscription?.state]);

  if (loading) {
    return (
      <div className="flex items-center justify-center h-screen">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4"></div>
          <p className="text-slate-600">Cargando documentos...</p>
        </div>
      </div>
    );
  }

  if (!postulant || !stats) {
    return (
      <div className="flex flex-col items-center justify-center h-screen">
        <AlertTriangle className="w-16 h-16 text-slate-400 mb-4" />
        <h2 className="text-2xl font-bold mb-2">Postulante no encontrado</h2>
        <p className="text-slate-600 mb-4">
          No se pudo encontrar informaci√≥n para el DNI: {dni}
        </p>
        <Button onClick={() => router.back()}>
          <ArrowLeft className="w-4 h-4 mr-2" />
          Volver
        </Button>
      </div>
    );
  }

  return (
    <div className="h-screen flex flex-col bg-background">
      {/* Header */}
      <div className="bg-card border-b border-border px-6 py-4">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-4">
            <SidebarTrigger />
            <Button variant="outline" size="icon" onClick={() => router.back()}>
              <ArrowLeft className="w-4 h-4" />
            </Button>
            <div>
              <h1 className="text-2xl font-bold text-card-foreground">
                Validaci√≥n de Documentos
              </h1>
              <div className="flex items-center gap-2 flex-wrap">
                <p className="text-muted-foreground">
                  {postulant.user.fullName} ‚Ä¢ DNI: {postulant.user.dni}
                </p>
                <Badge 
                  variant={
                    postulant.inscription.state === 'APPROVED' ? 'default' :
                    postulant.inscription.state === 'REJECTED' ? 'destructive' :
                    postulant.inscription.state === 'PENDING' ? 'secondary' :
                    'outline'
                  }
                >
                  {postulant.inscription.state}
                </Badge>
                {(postulant.inscription.state === 'APPROVED' || postulant.inscription.state === 'REJECTED') && (
                  <AlertDialog>
                    <AlertDialogTrigger asChild>
                      <Button variant="outline" size="sm" className="gap-1">
                        <RefreshCw className="w-4 h-4" />
                        Revertir a Pendiente
                      </Button>
                    </AlertDialogTrigger>
                    <AlertDialogContent>
                      <AlertDialogHeader>
                        <AlertDialogTitle>¬øRevertir Estado de Postulaci√≥n?</AlertDialogTitle>
                        <AlertDialogDescription>
                          Esta acci√≥n revertir√° el estado de la postulaci√≥n de "{postulant.inscription.state}" a "PENDING", 
                          permitiendo una nueva evaluaci√≥n administrativa. Esta acci√≥n se registrar√° en el historial.
                        </AlertDialogDescription>
                      </AlertDialogHeader>
                      <AlertDialogFooter>
                        <AlertDialogCancel>Cancelar</AlertDialogCancel>
                        <AlertDialogAction onClick={revertPostulationState}>
                          Confirmar Reversi√≥n
                        </AlertDialogAction>
                      </AlertDialogFooter>
                    </AlertDialogContent>
                  </AlertDialog>
                )}
              </div>
            </div>
          </div>

          <div className="flex items-center gap-4">
            <KeyboardShortcuts />
            
            <div className="text-right">
              <div className="text-sm text-muted-foreground">
                Progreso: {stats.approved}/{stats.total} documentos
              </div>
              <div className="w-32">
                <Progress value={stats.completionPercentage} className="h-2" />
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* Main Content - Dynamic Layout */}
      <div className="flex-1 flex overflow-hidden">
        {/* Left Panel - Document List (Collapsible) */}
        <div 
          className={`bg-card border-r border-border overflow-y-auto transition-all duration-300 ${
            isSidebarCollapsed ? 'w-16' : 'w-80'
          }`}
        >
          <div className="flex items-center justify-between p-3 border-b border-border">
            {!isSidebarCollapsed && (
              <h3 className="font-semibold text-sm">Documentos</h3>
            )}
            <Button 
              variant="ghost" 
              size="sm" 
              onClick={() => setIsSidebarCollapsed(!isSidebarCollapsed)}
              className="p-2"
            >
              {isSidebarCollapsed ? (
                <PanelLeftOpen className="w-4 h-4" />
              ) : (
                <PanelLeftClose className="w-4 h-4" />
              )}
            </Button>
          </div>
          
          {!isSidebarCollapsed && (
            <DocumentList
              documents={documents}
              currentDocument={currentDocument}
              onDocumentSelect={setCurrentDocument}
              stats={
                stats || {
                  total: 0,
                  pending: 0,
                  approved: 0,
                  rejected: 0,
                  required: 0,
                  completionPercentage: 0,
                }
              }
            />
          )}
          
          {isSidebarCollapsed && (
            <div className="p-2 space-y-2">
              {documents.map((doc) => (
                <button
                  key={doc.id}
                  onClick={() => setCurrentDocument(doc)}
                  className={`w-full p-2 rounded transition-colors ${
                    doc.id === currentDocument?.id
                      ? 'bg-primary text-primary-foreground'
                      : 'hover:bg-muted'
                  }`}
                  title={doc.originalName || doc.fileName}
                >
                  {doc.validationStatus === "APPROVED" ? (
                    <CheckCircle className="w-4 h-4 text-green-600" />
                  ) : doc.validationStatus === "REJECTED" ? (
                    <XCircle className="w-4 h-4 text-red-600" />
                  ) : (
                    <Clock className="w-4 h-4 text-blue-600" />
                  )}
                </button>
              ))}
            </div>
          )}
        </div>

        {/* Center Panel - Document Viewer */}
        <div className={`bg-muted flex-1 transition-all duration-300 ${isFullscreen ? 'fixed inset-0 z-50' : ''}`}>
          <DocumentViewer 
            document={currentDocument} 
            onNext={goToNextPending}
            onPrevious={goToPreviousPending}
            documents={documents}
            stats={stats}
            postulant={postulant}
            isFullscreen={isFullscreen}
            onFullscreenToggle={setIsFullscreen}
          />
        </div>

        {/* Right Panel - Validation Actions */}
        <div className="w-80 bg-card border-l border-border overflow-y-auto">
          {postulant && (
            <ValidationPanel
              document={currentDocument}
              postulant={postulant}
              onApprove={handleApprove}
              onReject={() => setShowRejectionForm(true)}
              onRevertStatus={handleRevertStatus}
              submitting={submitting}
              comments={comments}
              onCommentsChange={setComments}
              showRejectionForm={showRejectionForm}
              rejectionReason={rejectionReason}
              onRejectionReasonChange={setRejectionReason}
              onConfirmReject={handleReject}
              onCancelReject={() => {
                setShowRejectionForm(false);
                setRejectionReason("");
                setComments("");
              }}
            />
          )}
        </div>
      </div>

      {/* Validation Completion Modal */}
      {showCompletionModal && postulant && (
        <ValidationCompletionModal
          open={showCompletionModal}
          onOpenChange={(open) => {
            console.log('üîÑ Modal onOpenChange called with:', open);
            setShowCompletionModal(open);
            if (!open) {
              // When modal is closed via onOpenChange (like clicking outside or ESC), mark as dismissed
              console.log('‚ùå Modal dismissed by user - marking as dismissed');
              setModalDismissed(true);
            }
          }}
          documents={documents}
          postulant={{
            user: {
              dni: postulant.user.dni,
              fullName: postulant.user.fullName,
              email: postulant.user.email,
              telefono: "" // This would need to be added to the PostulantInfo interface
            },
            inscription: postulant.inscription,
            contest: postulant.contest
          }}
          onApprovePostulation={handleApprovePostulationAndNext}
          onRejectPostulation={handleRejectPostulationAndNext}
          onInitiateValidation={handleInitiateValidation}
          onGenerateEmailTemplate={handleGenerateEmailTemplate}
          onNextPostulation={handleNextPostulation}
        />
      )}
    </div>
  );
}

// Document List Component
function DocumentList({
  documents,
  currentDocument,
  onDocumentSelect,
  stats,
}: {
  documents: Document[];
  currentDocument: Document | null;
  onDocumentSelect: (doc: Document) => void;
  stats: ValidationData["stats"];
}) {
  const pendingDocs = documents.filter(
    (doc) => doc.validationStatus === "PENDING"
  );
  const approvedDocs = documents.filter(
    (doc) => doc.validationStatus === "APPROVED"
  );
  const rejectedDocs = documents.filter(
    (doc) => doc.validationStatus === "REJECTED"
  );

  const getStatusIcon = (status: string) => {
    switch (status) {
      case "APPROVED":
        return <CheckCircle className="w-4 h-4 text-emerald-500" />;
      case "REJECTED":
        return <XCircle className="w-4 h-4 text-red-500" />;
      default:
        return <Clock className="w-4 h-4 text-blue-500" />;
    }
  };

  const getStatusColor = (status: string) => {
    switch (status) {
      case "APPROVED":
        return "bg-emerald-50 dark:bg-emerald-900/20 border-emerald-200 dark:border-emerald-800";
      case "REJECTED":
        return "bg-red-50 dark:bg-red-900/20 border-red-200 dark:border-red-800";
      default:
        return "bg-blue-50 dark:bg-blue-900/20 border-blue-200 dark:border-blue-800";
    }
  };

  return (
    <div className="h-full flex flex-col">
      {/* Progress Header */}
      <div className="p-4 border-b border-border">
        <div className="text-sm text-muted-foreground mb-2">
          Progreso: {stats.approved + stats.rejected}/{stats.total} documentos
        </div>
        <Progress
          value={((stats.approved + stats.rejected) / stats.total) * 100}
          className="h-2"
        />

        <div className="grid grid-cols-3 gap-2 mt-3 text-xs">
          <div className="text-center">
            <div className="font-semibold text-blue-600">{stats.pending}</div>
            <div className="text-slate-500">Pendientes</div>
          </div>
          <div className="text-center">
            <div className="font-semibold text-emerald-600">
              {stats.approved}
            </div>
            <div className="text-slate-500">Aprobados</div>
          </div>
          <div className="text-center">
            <div className="font-semibold text-red-600">{stats.rejected}</div>
            <div className="text-slate-500">Rechazados</div>
          </div>
        </div>
      </div>

      {/* Document Lists */}
      <div className="flex-1 overflow-y-auto">
        {/* Pending Documents */}
        {pendingDocs.length > 0 && (
          <div className="p-3">
            <h3 className="text-sm font-semibold text-card-foreground mb-3 flex items-center gap-2">
              <Clock className="w-4 h-4 text-blue-500" />
              Pendientes ({pendingDocs.length})
            </h3>
            <div className="space-y-2">
              {pendingDocs.map((doc) => (
                <DocumentListItem
                  key={doc.id}
                  document={doc}
                  isActive={doc.id === currentDocument?.id}
                  onClick={() => onDocumentSelect(doc)}
                  statusIcon={getStatusIcon(doc.validationStatus)}
                  statusColor={getStatusColor(doc.validationStatus)}
                />
              ))}
            </div>
          </div>
        )}

        {/* Approved Documents */}
        {approvedDocs.length > 0 && (
          <div className="p-3 border-t border-border">
            <h3 className="text-sm font-semibold text-card-foreground mb-3 flex items-center gap-2">
              <CheckCircle className="w-4 h-4 text-emerald-500" />
              Aprobados ({approvedDocs.length})
            </h3>
            <div className="space-y-2">
              {approvedDocs.map((doc) => (
                <DocumentListItem
                  key={doc.id}
                  document={doc}
                  isActive={doc.id === currentDocument?.id}
                  onClick={() => onDocumentSelect(doc)}
                  statusIcon={getStatusIcon(doc.validationStatus)}
                  statusColor={getStatusColor(doc.validationStatus)}
                />
              ))}
            </div>
          </div>
        )}

        {/* Rejected Documents */}
        {rejectedDocs.length > 0 && (
          <div className="p-3 border-t border-border">
            <h3 className="text-sm font-semibold text-card-foreground mb-3 flex items-center gap-2">
              <XCircle className="w-4 h-4 text-red-500" />
              Rechazados ({rejectedDocs.length})
            </h3>
            <div className="space-y-2">
              {rejectedDocs.map((doc) => (
                <DocumentListItem
                  key={doc.id}
                  document={doc}
                  isActive={doc.id === currentDocument?.id}
                  onClick={() => onDocumentSelect(doc)}
                  statusIcon={getStatusIcon(doc.validationStatus)}
                  statusColor={getStatusColor(doc.validationStatus)}
                />
              ))}
            </div>
          </div>
        )}
      </div>
    </div>
  );
}

// Document List Item Component
function DocumentListItem({
  document,
  isActive,
  onClick,
  statusIcon,
  statusColor,
}: {
  document: Document;
  isActive: boolean;
  onClick: () => void;
  statusIcon: React.ReactNode;
  statusColor: string;
}) {
  return (
    <div
      onClick={onClick}
      className={`p-3 rounded-lg border cursor-pointer transition-all duration-200 hover:shadow-md ${
        isActive
          ? "ring-2 ring-blue-500 bg-blue-50 dark:bg-blue-900/20"
          : statusColor
      }`}
    >
      <div className="flex items-start gap-3">
        <div className="flex-shrink-0 mt-0.5">{statusIcon}</div>

        <div className="flex-1 min-w-0">
          <div className="flex items-center gap-2 mb-1">
            <h4 className="font-medium text-sm text-card-foreground truncate">
              {document.originalName || document.fileName}
            </h4>
            {document.isRequired && (
              <div
                className="bg-amber-100 dark:bg-amber-900/30 text-amber-700 dark:text-amber-400 rounded-full p-0.5"
                title="Documento obligatorio"
              >
                <AlertTriangle className="w-3 h-3" />
              </div>
            )}
          </div>

          <DocumentTypeBadge
            documentType={document.documentType}
            variant="compact"
          />

          <div className="text-xs text-muted-foreground mt-1">
            {(document.fileSize / 1024 / 1024).toFixed(1)} MB
          </div>
        </div>
      </div>
    </div>
  );
}

// Document Viewer Component
function DocumentViewer({
  document,
  onNext,
  onPrevious,
  documents,
  stats,
  postulant,
  isFullscreen = false,
  onFullscreenToggle,
}: {
  document: Document | null;
  onNext: () => void;
  onPrevious?: () => void;
  documents?: Document[];
  stats?: ValidationData["stats"];
  postulant?: PostulantInfo;
  isFullscreen?: boolean;
  onFullscreenToggle?: (fullscreen: boolean) => void;
}) {
  const [iframeKey, setIframeKey] = useState(0);
  const [prevFullscreen, setPrevFullscreen] = useState(isFullscreen);

  // Force iframe re-render when fullscreen changes
  useEffect(() => {
    if (prevFullscreen !== isFullscreen) {
      // Small delay to ensure DOM has updated
      setTimeout(() => {
        setIframeKey(prev => prev + 1);
      }, 100);
      setPrevFullscreen(isFullscreen);
    }
  }, [isFullscreen, prevFullscreen]);

  // Check if all required documents are validated
  const requiredDocs = documents?.filter(doc => doc.isRequired) || [];
  const requiredValidated = requiredDocs.every(doc => doc.validationStatus !== "PENDING");
  const showNextPostulationButton = requiredValidated && requiredDocs.length > 0;
  if (!document) {
    return (
      <div className="h-full flex items-center justify-center">
        <div className="text-center">
          <FileText className="w-16 h-16 text-slate-400 mx-auto mb-4" />
          <p className="text-slate-600 dark:text-slate-400">
            Selecciona un documento para visualizar
          </p>
        </div>
      </div>
    );
  }

  return (
    <div className="h-full flex flex-col">
      {/* Viewer Header */}
      <div className="bg-card border-b border-border p-4">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-3">
            <FileText className="w-5 h-5 text-muted-foreground" />
            <div>
              <h3 className="font-semibold text-card-foreground">
                {document.originalName || document.fileName}
              </h3>
              <p className="text-sm text-muted-foreground">
                {document.documentType} ‚Ä¢{" "}
                {(document.fileSize / 1024 / 1024).toFixed(1)} MB
              </p>
            </div>
          </div>

          <div className="flex items-center gap-2">
            <Button
              variant="outline"
              size="sm"
              onClick={() => onFullscreenToggle?.(!isFullscreen)}
              title={isFullscreen ? "Salir de pantalla completa" : "Pantalla completa"}
            >
              {isFullscreen ? <Minimize className="w-4 h-4" /> : <Maximize className="w-4 h-4" />}
            </Button>

            {showNextPostulationButton ? (
              <Button 
                variant="default" 
                size="sm" 
                className="bg-green-600 hover:bg-green-700 text-white"
                onClick={() => {
                  console.log("üöÄ Pr√≥xima Postulaci√≥n clicked");
                  navigateToNextPostulant();
                }}
              >
                <Target className="w-4 h-4 mr-2" />
                Pr√≥xima Postulaci√≥n
              </Button>
            ) : (
              <div className="flex items-center gap-1">
                {onPrevious && (
                  <Button 
                    variant="outline" 
                    size="sm" 
                    onClick={onPrevious}
                    title="Documento anterior"
                  >
                    <ChevronLeft className="w-4 h-4" />
                  </Button>
                )}
                
                <Button variant="outline" size="sm" onClick={onNext}>
                  <ChevronRight className="w-4 h-4" />
                </Button>
              </div>
            )}
          </div>
        </div>
      </div>

      {/* Document Preview */}
      <div className="flex-1 bg-muted p-4">
        <div className="h-full bg-card rounded-lg shadow-sm border border-border overflow-hidden">
          {document.fileName.toLowerCase().endsWith(".pdf") ? (
            <iframe
              key={`${document.id}-${iframeKey}`}
              src={apiUrl(`documents/${document.id}/view`)}
              className="w-full h-full border-0"
              title={document.originalName}
              onLoad={() => {
                // Additional handling if needed when PDF loads
              }}
            />
          ) : (
            <div className="h-full flex items-center justify-center">
              <img
                src={apiUrl(`documents/${document.id}/view`)}
                alt={document.originalName}
                className="max-w-full max-h-full object-contain"
              />
            </div>
          )}
        </div>
      </div>
    </div>
  );
}

// Validation Panel Component
function ValidationPanel({
  document,
  postulant,
  onApprove,
  onReject,
  onRevertStatus,
  submitting,
  comments,
  onCommentsChange,
  showRejectionForm,
  rejectionReason,
  onRejectionReasonChange,
  onConfirmReject,
  onCancelReject,
}: {
  document: Document | null;
  postulant: PostulantInfo;
  onApprove: () => void;
  onReject: () => void;
  onRevertStatus: () => void;
  submitting: boolean;
  comments: string;
  onCommentsChange: (value: string) => void;
  showRejectionForm: boolean;
  rejectionReason: string;
  onRejectionReasonChange: (value: string) => void;
  onConfirmReject: () => void;
  onCancelReject: () => void;
}) {
  if (!document) {
    return (
      <div className="h-full flex items-center justify-center p-6">
        <div className="text-center">
          <User className="w-16 h-16 text-slate-400 mx-auto mb-4" />
          <p className="text-slate-600 dark:text-slate-400">
            Selecciona un documento para validar
          </p>
        </div>
      </div>
    );
  }

  return (
    <div className="h-full flex flex-col">
      {/* Previous Validation Info - Only if exists */}
      {(document.validatedBy ||
        document.comments ||
        document.rejectionReason) && (
        <div className="p-6 border-b border-border">
          <h3 className="font-semibold text-card-foreground mb-4 flex items-center gap-2">
            <Calendar className="w-5 h-5" />
            Validaci√≥n Anterior
          </h3>

          <div className="space-y-3">
            {document.validatedBy && (
              <div>
                <div className="text-sm font-medium text-muted-foreground">
                  Validado por:
                </div>
                <div className="text-sm text-card-foreground">
                  {document.validatedBy}
                </div>
              </div>
            )}

            {document.validatedAt && (
              <div>
                <div className="text-sm font-medium text-muted-foreground">
                  Fecha:
                </div>
                <div className="text-sm text-card-foreground">
                  {new Date(document.validatedAt).toLocaleString("es-ES")}
                </div>
              </div>
            )}

            {document.rejectionReason && (
              <div>
                <div className="text-sm font-medium text-muted-foreground">
                  Motivo de rechazo:
                </div>
                <div className="text-sm text-red-700 dark:text-red-400">
                  {document.rejectionReason}
                </div>
              </div>
            )}

            {document.comments && (
              <div>
                <div className="text-sm font-medium text-muted-foreground">
                  Comentarios:
                </div>
                <div className="text-sm text-card-foreground">
                  {document.comments}
                </div>
              </div>
            )}
          </div>
        </div>
      )}

      {/* Validation Actions */}
      <div className="flex-1 p-6">
        {document.validationStatus === "PENDING" ? (
          <div className="space-y-4">
            <h3 className="font-semibold text-card-foreground">
              Acciones de Validaci√≥n
            </h3>

            {!showRejectionForm ? (
              <>
                {/* Comments */}
                <div>
                  <label className="text-sm font-medium text-card-foreground mb-2 block">
                    Comentarios (opcional):
                  </label>
                  <Textarea
                    placeholder="Agregue comentarios sobre el documento..."
                    value={comments}
                    onChange={(e) => onCommentsChange(e.target.value)}
                    rows={3}
                    className="resize-none"
                  />
                </div>

                {/* Action Buttons */}
                <div className="space-y-3">
                  <Button
                    onClick={onApprove}
                    disabled={submitting}
                    className="w-full bg-emerald-600 hover:bg-emerald-700 text-white"
                    size="lg"
                  >
                    <CheckCircle className="w-5 h-5 mr-2" />
                    {submitting ? "Aprobando..." : "Aprobar Documento (A)"}
                  </Button>

                  <Button
                    onClick={onReject}
                    disabled={submitting}
                    variant="destructive"
                    className="w-full"
                    size="lg"
                  >
                    <XCircle className="w-5 h-5 mr-2" />
                    Rechazar Documento (R)
                  </Button>
                </div>
              </>
            ) : (
              <>
                {/* Rejection Form */}
                <div className="space-y-4">
                  <div>
                    <label className="text-sm font-medium text-card-foreground mb-2 block">
                      Motivo del rechazo:
                    </label>
                    <Select
                      value={rejectionReason}
                      onValueChange={onRejectionReasonChange}
                    >
                      <SelectTrigger>
                        <SelectValue placeholder="Seleccionar motivo..." />
                      </SelectTrigger>
                      <SelectContent>
                        {REJECTION_REASONS.map((reason) => (
                          <SelectItem key={reason} value={reason}>
                            {reason}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  </div>

                  <div>
                    <label className="text-sm font-medium text-card-foreground mb-2 block">
                      Comentarios adicionales (opcional):
                    </label>
                    <Textarea
                      placeholder="Proporcione detalles espec√≠ficos sobre el rechazo..."
                      value={comments}
                      onChange={(e) => onCommentsChange(e.target.value)}
                      rows={3}
                      className="resize-none"
                    />
                  </div>

                  <div className="flex gap-2">
                    <Button
                      onClick={onCancelReject}
                      variant="outline"
                      className="flex-1"
                    >
                      Cancelar
                    </Button>
                    <Button
                      onClick={onConfirmReject}
                      disabled={!rejectionReason.trim() || submitting}
                      variant="destructive"
                      className="flex-1"
                    >
                      <XCircle className="w-4 h-4 mr-2" />
                      {submitting ? "Rechazando..." : "Confirmar Rechazo"}
                    </Button>
                  </div>
                </div>
              </>
            )}

            {/* Keyboard Shortcuts Help */}
            <KeyboardShortcutsHelp className="mt-6" />
          </div>
        ) : (
          <div className="space-y-4">
            <h3 className="font-semibold text-card-foreground">
              Estado del Documento
            </h3>
            
            <div className="text-center py-6">
              <div
                className={`inline-flex items-center gap-2 px-4 py-2 rounded-lg mb-4 ${
                  document.validationStatus === "APPROVED"
                    ? "bg-emerald-100 dark:bg-emerald-900/20 text-emerald-700 dark:text-emerald-400"
                    : "bg-red-100 dark:bg-red-900/20 text-red-700 dark:text-red-400"
                }`}
              >
                {document.validationStatus === "APPROVED" ? (
                  <CheckCircle className="w-5 h-5" />
                ) : (
                  <XCircle className="w-5 h-5" />
                )}
                <span className="font-medium">
                  {document.validationStatus === "APPROVED"
                    ? "Documento Aprobado"
                    : "Documento Rechazado"}
                </span>
              </div>
              
              <p className="text-sm text-slate-600 dark:text-slate-400 mb-4">
                Este documento ya ha sido validado
              </p>
              
              <Button
                onClick={onRevertStatus}
                variant="outline"
                size="sm"
                className="flex items-center gap-2"
              >
                <Clock className="w-4 h-4" />
                Revertir a Pendiente
              </Button>
            </div>
          </div>
        )}
      </div>
    </div>
  );
}
