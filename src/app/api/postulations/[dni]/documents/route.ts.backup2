import { NextRequest, NextResponse } from 'next/server';
import backendClient from '@/lib/backend-client';
import fs from 'fs';
import path from 'path';

/**
 * @fileOverview API para obtener documentos de un postulante espec√≠fico
 * Combina informaci√≥n del postulante con sus documentos y calcula el estado de validaci√≥n
 */

interface Document {
  id: string;
  fileName: string;
  originalName: string;
  filePath: string;
  fileSize: number;
  documentType: string;
  validationStatus: 'PENDING' | 'APPROVED' | 'REJECTED';
  isRequired: boolean;
  uploadDate: string;
  validatedAt?: string;
  validatedBy?: string;
  comments?: string;
  rejectionReason?: string;
  thumbnailUrl?: string;
}

interface PostulantInfo {
  user: {
    dni: string;
    fullName: string;
    email: string;
  };
  inscription: {
    id: string;
    state: string;
    centroDeVida: string;
    createdAt: string;
  };
  contest: {
    id: number;
    title: string;
    category: string;
    position: string;
    department: string;
    contestClass: string;
    status: string;
    statusDescription: string;
    inscriptionStartDate: string;
    inscriptionEndDate: string;
    dependency?: string;
    location?: string;
  };
}

interface DocumentsPageData {
  postulant: PostulantInfo;
  documents: Document[];
  stats: {
    total: number;
    pending: number;
    approved: number;
    rejected: number;
    required: number;
    completionPercentage: number;
  };
  validationStatus: 'PENDING' | 'PARTIAL' | 'COMPLETED' | 'REJECTED';
}

// Configuration for file storage based on MPD system architecture
// Environment-aware path configuration for dev/prod compatibility
const NODE_ENV = process.env.NODE_ENV || 'development';
const IS_PRODUCTION = NODE_ENV === 'production';

// Primary document storage path - should be configured via environment variables
const PRIMARY_DOCS_PATH = process.env.DOCUMENTS_PATH;

// Backend-aligned configuration (matches Spring Boot StorageConfig)
const STORAGE_BASE_DIR = process.env.APP_STORAGE_BASE_DIR || (IS_PRODUCTION ? '/app/storage' : './storage');
const DOCUMENTS_DIR = process.env.APP_STORAGE_DOCUMENTS_DIR || 'documents';

// Development-specific paths
const LOCAL_DOCS_PATH = process.env.LOCAL_DOCUMENTS_PATH || 'B:\\concursos_situacion_post_gracia\\descarga_administracion_20250814_191745\\documentos';

// Backend storage path (for development when running both frontend and backend)
const BACKEND_STORAGE_PATH = process.env.DOCUMENT_STORAGE_PATH || "/var/lib/docker/volumes/mpd_concursos_storage_data_prod/_data/documents";

// Production-ready path resolution
const getDocumentBasePaths = (): string[] => {
  const paths: string[] = [];
  
  // 1. Primary path from environment (highest priority)
  if (PRIMARY_DOCS_PATH) {
    paths.push(PRIMARY_DOCS_PATH);
    console.log(`üìÅ Using primary documents path: ${PRIMARY_DOCS_PATH}`);
  }
  
  // 2. Production paths
  if (IS_PRODUCTION) {
    paths.push(
      '/app/storage/documents',
      '/var/lib/mpd-documents',
      '/opt/mpd/documents',
      path.join(STORAGE_BASE_PATH, DOCUMENTS_DIR)
    );
  } else {
    // 3. Development paths
    paths.push(
      BACKEND_STORAGE_PATH,    // Backend storage first (most likely to work in dev)
      LOCAL_DOCS_PATH,
      path.join(process.cwd(), 'storage', 'documents'),
      path.join(process.cwd(), 'uploads'),
      path.join(STORAGE_BASE_PATH, DOCUMENTS_DIR)
    );
  }
  
  // 4. Additional fallbacks for both environments
  paths.push(
    path.join('C:', 'app', 'storage', 'documents'),
    '/tmp/mpd-documents'
  );
  
  // Remove duplicates and log final paths
  const uniquePaths = [...new Set(paths)];
  console.log(`üìÅ Document base paths (${NODE_ENV}):`, uniquePaths);
  
  return uniquePaths;
};

// Tipos de documentos obligatorios - usando nombres reales del sistema
const REQUIRED_DOCUMENT_TYPES = [
  'DNI (Frontal)',
  'DNI (Dorso)', 
  'T√≠tulo Universitario y Certificado Anal√≠tico',
  'Certificado de Antecedentes Penales',
  'Certificado Sin Sanciones Disciplinarias',
  'Certificado de Antig√ºedad Profesional',
  'Constancia de CUIL'
  // Nota: 'Certificado Ley Micaela' es opcional, no requerido para este concurso
];

/**
 * Get file size from filesystem with fuzzy matching by document ID
 * @param filePath - Relative path from database (format: "dni/filename")
 * @param documentId - Document UUID for fuzzy matching
 * @returns File size in bytes or 0 if file doesn't exist
 */
async function getFileSize(filePath: string, documentId?: string): Promise<number> {
  if (!filePath) {
    console.warn(`üìè getFileSize: filePath is empty`);
    return 0;
  }
  
  try {
    console.log(`üìè getFileSize: Processing filePath: "${filePath}" with documentId: "${documentId}"`);
    
    // Extract DNI from filePath (e.g., "35515608/filename.pdf" -> "35515608")
    const pathParts = filePath.split('/');
    const dni = pathParts[0];
    const fileName = pathParts[pathParts.length - 1];
    
    console.log(`üìè getFileSize: Extracted DNI: "${dni}", fileName: "${fileName}"`);
    
    // Get environment-aware document base paths
    const possibleBasePaths = getDocumentBasePaths();
    
    console.log(`üìè getFileSize: Environment = ${NODE_ENV}, Checking ${possibleBasePaths.length} possible base paths`);
    
    // First, try exact path matching
    for (const basePath of possibleBasePaths) {
      const exactPath = path.join(basePath, filePath);
      try {
        console.log(`üìè getFileSize: Trying exact path: "${exactPath}"`);
        const stats = await fs.promises.stat(exactPath);
        if (stats.isFile()) {
          console.log(`‚úÖ getFileSize: File found (exact match)! Size: ${stats.size} bytes at "${exactPath}"`);
          return stats.size;
        }
      } catch (err: any) {
        console.log(`‚ùå getFileSize: Exact path failed: ${err.code || err.message}`);
        continue;
      }
    }
    
    // If exact match fails and we have a documentId, try fuzzy matching
    if (documentId && dni) {
      console.log(`üìè getFileSize: Exact match failed, trying fuzzy matching with documentId: ${documentId}`);
      
      for (const basePath of possibleBasePaths) {
        const userDir = path.join(basePath, dni);
        try {
          const files = await fs.promises.readdir(userDir);
          console.log(`üìè getFileSize: Found ${files.length} files in "${userDir}"`);
          
          // Look for files that start with the documentId
          const matchingFile = files.find(file => file.startsWith(documentId));
          
          if (matchingFile) {
            const fullPath = path.join(userDir, matchingFile);
            console.log(`üìè getFileSize: Found fuzzy match: "${matchingFile}"`);
            
            const stats = await fs.promises.stat(fullPath);
            if (stats.isFile()) {
              console.log(`‚úÖ getFileSize: File found (fuzzy match)! Size: ${stats.size} bytes at "${fullPath}"`);
              return stats.size;
            }
          }
        } catch (err: any) {
          console.log(`‚ùå getFileSize: Fuzzy matching in "${userDir}" failed: ${err.code || err.message}`);
          continue;
        }
      }
    }
    
    // If no file found, return 0
    console.warn(`üìè getFileSize: Could not find file in any path for: ${filePath}`);
    return 0;
  } catch (error) {
    console.error(`üìè getFileSize: Unexpected error for ${filePath}:`, error);
    return 0;
  }
}

/**
 * Calculate file sizes for documents concurrently
 * @param documents - Array of document objects
 * @returns Array of documents with calculated file sizes
 */
async function calculateFileSizes(documents: Document[]): Promise<Document[]> {
  console.log(`üîß calculateFileSizes: Processing ${documents.length} documents`);
  
  const sizePromises = documents.map(async (doc, index) => {
    console.log(`üîß calculateFileSizes: Processing document ${index + 1}/${documents.length}: ID=${doc.id}, filePath="${doc.filePath}"`);
    const calculatedFileSize = await getFileSize(doc.filePath, doc.id);
    console.log(`üîß calculateFileSizes: Document ${index + 1} result: ${calculatedFileSize} bytes`);
    return {
      ...doc,
      fileSize: calculatedFileSize > 0 ? calculatedFileSize : doc.fileSize
    };
  });
  
  const results = await Promise.all(sizePromises);
  console.log(`üîß calculateFileSizes: Completed processing all documents`);
  return results;
}

// Funci√≥n para determinar si un documento es obligatorio
function isRequiredDocument(documentType: string): boolean {
  return REQUIRED_DOCUMENT_TYPES.includes(documentType);
}

// Funci√≥n para mapear estados del concurso a descripciones en espa√±ol
function getContestStatusDescription(status: string): string {
  const statusMap: { [key: string]: string } = {
    'DRAFT': 'Borrador',
    'SCHEDULED': 'Programado',
    'ACTIVE': 'Activo - Inscripciones Abiertas',
    'CLOSED': 'Cerrado para Inscripciones - Periodo de Validaci√≥n de Documentaci√≥n',
    'PAUSED': 'Pausado',
    'CANCELLED': 'Cancelado',
    'FINISHED': 'Finalizado',
    'ARCHIVED': 'Archivado',
    'IN_EVALUATION': 'En Evaluaci√≥n',
    'RESULTS_PUBLISHED': 'Resultados Publicados'
  };
  
  return statusMap[status] || status;
}

// Funci√≥n para obtener informaci√≥n detallada del concurso
async function getContestDetails(contestId: number): Promise<any> {
  try {
    console.log(`üèÜ Getting contest details for ID: ${contestId}`);
    
    // Usar endpoint local en lugar del backend externo
    const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000';
    const response = await fetch(`${baseUrl}/api/contests/${contestId}`, {
      headers: {
        'Accept': 'application/json',
      }
    });
    
    if (!response.ok) {
      console.warn(`‚ùå Contest API returned ${response.status} for contest ${contestId}`);
      return null;
    }
    
    const apiResponse = await response.json();
    const contestData = apiResponse.data;
    
    console.log(`‚úÖ Retrieved contest data:`, {
      id: contestData.id,
      title: contestData.title,
      category: contestData.category,
      contestClass: contestData.contestClass,
      status: contestData.status,
      inscriptionStartDate: contestData.inscriptionStartDate,
      inscriptionEndDate: contestData.inscriptionEndDate
    });
    
    return contestData;
  } catch (error) {
    console.error(`‚ùå Error fetching contest ${contestId}:`, error);
    return null;
  }
}

// Funci√≥n para calcular el estado de validaci√≥n general
function calculateValidationStatus(documents: Document[]): {
  status: 'PENDING' | 'PARTIAL' | 'COMPLETED' | 'REJECTED';
  completionPercentage: number;
} {
  if (documents.length === 0) {
    return { status: 'PENDING', completionPercentage: 0 };
  }

  // Calcular progreso basado en TODOS los documentos (obligatorios + opcionales)
  const validatedDocsCount = documents.filter(doc => doc.validationStatus !== 'PENDING').length;
  const progressPercentage = Math.round((validatedDocsCount / documents.length) * 100);

  const requiredDocs = documents.filter(doc => doc.isRequired);
  
  if (requiredDocs.length === 0) {
    // Si no hay documentos obligatorios, basarse en todos los documentos
    const approvedCount = documents.filter(doc => doc.validationStatus === 'APPROVED').length;
    const rejectedCount = documents.filter(doc => doc.validationStatus === 'REJECTED').length;
    
    if (rejectedCount > 0) return { status: 'REJECTED', completionPercentage: progressPercentage };
    if (approvedCount === documents.length) return { status: 'COMPLETED', completionPercentage: progressPercentage };
    if (approvedCount > 0) return { status: 'PARTIAL', completionPercentage: progressPercentage };
    return { status: 'PENDING', completionPercentage: progressPercentage };
  }

  const approvedRequired = requiredDocs.filter(doc => doc.validationStatus === 'APPROVED').length;
  const rejectedRequired = requiredDocs.filter(doc => doc.validationStatus === 'REJECTED').length;

  // Si hay documentos obligatorios rechazados, est√° rechazado
  if (rejectedRequired > 0) {
    return { status: 'REJECTED', completionPercentage: progressPercentage };
  }

  // Si todos los obligatorios est√°n aprobados, est√° completado
  if (approvedRequired === requiredDocs.length) {
    return { status: 'COMPLETED', completionPercentage: progressPercentage };
  }

  // Si algunos est√°n aprobados, est√° parcial
  if (approvedRequired > 0) {
    return { status: 'PARTIAL', completionPercentage: progressPercentage };
  }

  // Todos pendientes
  return { status: 'PENDING', completionPercentage: progressPercentage };
}

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ dni: string }> }
) {
  try {
    const { dni } = await params;
    console.log(`üîç Fetching documents for postulant with DNI: ${dni}`);

    // Login to get token (same pattern as working validation endpoint)
    const loginResponse = await fetch('http://localhost:8080/api/auth/login', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      },
      body: JSON.stringify({
        username: 'admin',
        password: 'admin123'
      })
    });

    if (!loginResponse.ok) {
      throw new Error('Login failed');
    }

    const loginData = await loginResponse.json();
    console.log('‚úÖ Login successful for documents endpoint');

    // Buscar usuario por DNI - obtener todos los usuarios directamente del backend
    const usersResponse = await fetch('http://localhost:8080/api/users?size=1000', {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        'Authorization': `Bearer ${loginData.token}`
      }
    });

    if (!usersResponse.ok) {
      const errorText = await usersResponse.text();
      return NextResponse.json({
        success: false,
        error: 'Failed to fetch users from backend',
        details: errorText,
        timestamp: new Date().toISOString()
      }, { status: 500 });
    }

    const usersData = await usersResponse.json();
    console.log('‚úÖ Users fetched:', usersData.totalElements);

    // Buscar el usuario exacto por DNI en la lista completa
    const user = usersData.content.find((u: any) => 
      (u.dni === dni) || (u.username === dni)
    );

    if (!user) {
      return NextResponse.json({
        success: false,
        error: 'Postulant not found with exact DNI match',
        timestamp: new Date().toISOString()
      }, { status: 404 });
    }, { status: 404 });
    }

    console.log(`üë§ Found user: ${user.fullName || user.name} (ID: ${user.id})`);

    // Obtener inscripci√≥n del usuario
    const inscriptionsResponse = await fetch('http://localhost:8080/api/admin/inscriptions?userId=' + user.id + '&size=10', {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        'Authorization': `Bearer ${loginData.token}`
      }
    });

    let inscription = null;
    if (inscriptionsResponse.ok) {
      const inscriptionsData = await inscriptionsResponse.json();
      if (inscriptionsData.content && inscriptionsData.content.length > 0) {
        inscription = inscriptionsData.content[0]; // Tomar la primera inscripci√≥n
      }
    }

    // Obtener documentos del usuario
    const documentsResponse = await fetch('http://localhost:8080/api/admin/documentos?usuarioId=' + user.id + '&size=100', {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        'Authorization': `Bearer ${loginData.token}`
      }
    });

    if (!documentsResponse.ok) {
      const errorText = await documentsResponse.text();
      return NextResponse.json({
        success: false,
        error: 'Failed to fetch user documents',
        details: errorText,
        timestamp: new Date().toISOString()
      }, { status: 500 });
    }

    const documentsData = await documentsResponse.json();
    const backendDocuments = documentsData.content || [];
    console.log(`üìÑ Found ${backendDocuments.length} documents for user`), { status: 500 });
    }

    const backendDocuments = documentsResponse.data?.content || [];
    console.log(`üìÑ Found ${backendDocuments.length} documents for user`);

    // Funci√≥n para determinar el tipo de documento basado en el nombre del archivo
    const getDocumentTypeFromName = (fileName: string): string => {
      if (!fileName) return 'UNKNOWN';
      
      // Remover la extensi√≥n del archivo
      const nameWithoutExtension = fileName.replace(/\.[^/.]+$/, "");
      
      // Mapear nombres comunes a tipos de documento
      const nameMapping: { [key: string]: string } = {
        'DNI (Frontal)': 'DNI (Frontal)',
        'DNI (Dorso)': 'DNI (Dorso)', 
        'T√≠tulo Universitario y Certificado Anal√≠tico': 'T√≠tulo Universitario y Certificado Anal√≠tico',
        'Certificado de Antecedentes Penales': 'Certificado de Antecedentes Penales',
        'Certificado Sin Sanciones Disciplinarias': 'Certificado Sin Sanciones Disciplinarias',
        'Certificado de Antig√ºedad Profesional': 'Certificado de Antig√ºedad Profesional',
        'Constancia de CUIL': 'Constancia de CUIL',
        'Certificado Ley Micaela': 'Certificado Ley Micaela',
        'Documento Adicional': 'Documento Adicional'
      };
      
      // Buscar coincidencia exacta
      if (nameMapping[nameWithoutExtension]) {
        return nameMapping[nameWithoutExtension];
      }
      
      // Buscar coincidencia parcial (contiene)
      for (const [key, value] of Object.entries(nameMapping)) {
        if (nameWithoutExtension.toLowerCase().includes(key.toLowerCase()) || 
            key.toLowerCase().includes(nameWithoutExtension.toLowerCase())) {
          return value;
        }
      }
      
      // Si no se encuentra coincidencia, usar el nombre del archivo como tipo
      return nameWithoutExtension || 'UNKNOWN';
    };
    
    // Mapear documentos al formato requerido
    const documents: Document[] = backendDocuments.map((doc: any) => {
      const fileName = doc.fileName || doc.nombreArchivo;
      const originalName = doc.originalName || doc.nombreOriginal || fileName;
      const documentTypeFromBackend = doc.documentTypeId || doc.tipoDocumentoId || doc.documentType;
      
      // Construct filePath using DNI and filename since backend doesn't provide it
      const userDni = user.dni || user.username;
      const filePath = doc.filePath || doc.rutaArchivo || (userDni && fileName ? `${userDni}/${fileName}` : undefined);
      
      // Debug: Mostrar todos los campos relacionados con archivos
      console.log(`üìÑ DOC DEBUG - Processing document:`, {
        id: doc.id,
        fileName,
        originalName,
        filePath,
        fileSize: doc.fileSize || doc.tama√±o,
        documentType: documentTypeFromBackend
      });
      
      // Usar el tipo del backend si est√° disponible, sino inferir del nombre
      const documentType = documentTypeFromBackend && documentTypeFromBackend !== 'UNKNOWN' 
        ? documentTypeFromBackend 
        : getDocumentTypeFromName(originalName || fileName);
      
      const isDocumentRequired = isRequiredDocument(documentType);
      console.log(`üìÑ Document: ${documentType} - Required: ${isDocumentRequired}`);
      
      return {
        id: doc.id,
        fileName: fileName,
        originalName: originalName,
        filePath: filePath,
        fileSize: doc.fileSize || doc.tama√±o || 0,
        documentType: documentType,
        validationStatus: (doc.status || doc.estado || 'PENDING') as 'PENDING' | 'APPROVED' | 'REJECTED',
        isRequired: isDocumentRequired,
        uploadDate: doc.uploadDate || doc.fechaSubida || doc.createdAt || new Date().toISOString(),
        validatedAt: doc.validatedAt || doc.fechaValidacion,
        validatedBy: doc.validatedBy || doc.validadoPor,
        comments: doc.comments || doc.comentarios,
        rejectionReason: doc.rejectionReason || doc.motivoRechazo,
        thumbnailUrl: undefined // TODO: Implement thumbnail generation
      };
    });

    // Calcular tama√±os de archivos desde el sistema de archivos
    console.log(`üìè Calculating file sizes for ${documents.length} documents...`);
    const documentsWithSizes = await calculateFileSizes(documents);
    console.log(`üìè File sizes calculated successfully`);

    // Debug: Mostrar todos los documentos y su clasificaci√≥n
    console.log('üìä DEBUG - Document classification:');
    documentsWithSizes.forEach((doc, index) => {
      console.log(`  ${index + 1}. "${doc.documentType}" (${doc.originalName || doc.fileName}) - Required: ${doc.isRequired}`);
    });
    
    const requiredDocs = documentsWithSizes.filter(doc => doc.isRequired);
    console.log(`üìä DEBUG - Required documents found: ${requiredDocs.length} of ${REQUIRED_DOCUMENT_TYPES.length}`);
    console.log(`üìä DEBUG - Required document types:`, REQUIRED_DOCUMENT_TYPES);
    console.log(`üìä DEBUG - Found required docs:`, requiredDocs.map(doc => doc.documentType));

    // Calcular estad√≠sticas
    const stats = {
      total: documentsWithSizes.length,
      pending: documentsWithSizes.filter(doc => doc.validationStatus === 'PENDING').length,
      approved: documentsWithSizes.filter(doc => doc.validationStatus === 'APPROVED').length,
      rejected: documentsWithSizes.filter(doc => doc.validationStatus === 'REJECTED').length,
      required: requiredDocs.length,
      completionPercentage: 0
    };

    // Calcular estado de validaci√≥n general
    const { status: validationStatus, completionPercentage } = calculateValidationStatus(documents);
    stats.completionPercentage = completionPercentage;

    // Obtener informaci√≥n detallada del concurso si hay inscripci√≥n
    let contestDetails = null;
    if (inscription?.contestId) {
      contestDetails = await getContestDetails(inscription.contestId);
    }

    console.log(`üèÜ Contest details for modal:`, {
      contestId: inscription?.contestId,
      contestDetails: contestDetails ? {
        id: contestDetails.id,
        title: contestDetails.title,
        category: contestDetails.category,
        contestClass: contestDetails.contestClass,
        status: contestDetails.status
      } : 'Not found'
    });

    // Crear informaci√≥n del postulante con datos completos del concurso
    const postulantInfo: PostulantInfo = {
      user: {
        dni: user.dni || user.username,
        fullName: user.fullName || `${user.firstName || ''} ${user.lastName || ''}`.trim() || user.name,
        email: user.email
      },
      inscription: {
        id: inscription?.id || 'unknown',
        state: inscription?.state || inscription?.status || 'ACTIVE',
        centroDeVida: inscription?.centroDeVida || 'No especificada',
        createdAt: inscription?.createdAt || inscription?.inscriptionDate || new Date().toISOString()
      },
      contest: {
        id: contestDetails?.id || inscription?.contestId || 1,
        title: contestDetails?.title || inscription?.contest?.title || 'Concurso Multifuero MPD',
        category: contestDetails?.category || 'FUNCIONARIOS Y PERSONAL JER√ÅRQUICO',
        position: contestDetails?.position || 'Co-Defensor/Co-Asesor Multifuero',
        department: contestDetails?.department || contestDetails?.dependency || 'MULTIFUERO',
        contestClass: contestDetails?.contestClass || '03',
        status: contestDetails?.status || 'CLOSED',
        statusDescription: getContestStatusDescription(contestDetails?.status || 'CLOSED'),
        inscriptionStartDate: contestDetails?.inscriptionStartDate || contestDetails?.startDate || '2025-07-31T00:00:00',
        inscriptionEndDate: contestDetails?.inscriptionEndDate || contestDetails?.endDate || '2025-08-08T23:59:59',
        dependency: contestDetails?.dependency || contestDetails?.district,
        location: contestDetails?.location
      }
    };

    const result: DocumentsPageData = {
      postulant: postulantInfo,
      documents: documentsWithSizes,
      stats,
      validationStatus
    };

    // Log final de stats para debug del modal
    const allRequiredValidated = requiredDocs.length > 0 && requiredDocs.every(doc => doc.validationStatus !== "PENDING");
    
    console.log(`üìä MODAL DEBUG - Stats:`, {
      totalDocs: documents.length,
      requiredDocs: requiredDocs.length,
      allRequiredValidated,
      requiredDocsStatus: requiredDocs.map(doc => ({
        name: doc.documentType,
        status: doc.validationStatus,
        isRequired: doc.isRequired
      }))
    });
    
    console.log(`‚úÖ Returning ${documents.length} documents with ${stats.completionPercentage}% completion`);

    return NextResponse.json({
      success: true,
      data: result,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    console.error('‚ùå Postulant documents API error:', error);
    
    return NextResponse.json({
      success: false,
      error: 'Failed to fetch postulant documents',
      details: error instanceof Error ? error.message : 'Unknown error',
      timestamp: new Date().toISOString()
    }, { status: 500 });
  }
}
